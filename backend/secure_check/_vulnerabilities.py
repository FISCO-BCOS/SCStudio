# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

class VulInfo:
    def __init__(self, name, desc, swc, advice, level):
        self.name = name
        self.desc = desc
        self.swc = swc
        self.advice = advice
        self.level = level


__VULNERABILITIES = {
    1: VulInfo(
        name="Function or Variable Default Visibility",
        desc="Functions or variables that do not have a visibility type specified are public by default. This can lead to a vulnerability if a developer forgot to set the visibility and a malicious user is able to make unauthorized or unintended state changes.",
        swc="100",
        advice="Functions can be specified as being external, public, internal or private. It is recommended to make a conscious decision on which visibility type is appropriate for a function. This can dramatically reduce the attack surface of a contract system.",
        level="ignore",
    ),
    2: VulInfo(
        name="Integer Overflow or Underflow",
        desc="An overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type.",
        swc="101",
        advice="It is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system.",
        level="error",
    ),
    3: VulInfo(
        name="Outdated Compiler Version",
        desc="Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.",
        swc="102",
        advice="It is recommended to use a recent version of the Solidity compiler.",
        level="ignore",
    ),
    4: VulInfo(
        name="Unchecked Call Return Value",
        desc="The return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.",
        swc="104",
        advice="If you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value.",
        level="error",
    ),
    5: VulInfo(
        name="Unprotected Ether Withdrawal",
        desc="Due to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.",
        swc="105",
        advice="Implement controls so withdrawals can only be triggered by authorized parties or according to the specs of the smart contract system.",
        level="error",
    ),
    6: VulInfo(
        name="Unprotected SELFDESTRUCT Instruction",
        desc="Due to missing or insufficient access controls, malicious parties can self-destruct the contract.",
        swc="106",
        advice="Consider removing the self-destruct functionality unless it is absolutely required. If there is a valid use-case, it is recommended to implement a multisig scheme so that multiple parties must approve the self-destruct action.",
        level="error",
    ),
    7: VulInfo(
        name="Reentrancy",
        desc="One of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.",
        swc="107",
        advice="Use transfer() instead of contract.call() to transfer Ether to untrusted addresses. And when using low-level calls, make sure all internal state changes are performed before the call is executed.",
        level="error",
    ),
    8: VulInfo(
        name="Assert Violation",
        desc="Properly functioning code should never reach a failing assert statement.",
        swc="110",
        advice="Consider whether the condition checked in the assert() is actually an invariant. If not, replace the assert() statement with a require() statement. If the exception is indeed caused by unexpected behaviour of the code, fix the underlying bug(s) that allow the assertion to be violated.",
        level="error",
    ),
    9: VulInfo(
        name="Use of Deprecated Solidity Functions",
        desc="Several functions and operators in Solidity are deprecated. Using them leads to reduced code quality. With new major versions of the Solidity compiler, deprecated functions and operators may result in side effects and compile errors.",
        swc="111",
        advice="Solidity provides alternatives to the deprecated constructions. Most of them are aliases, thus replacing old constructions will not break current behavior.",
        level="ignore",
    ),
    10: VulInfo(
        name="Delegatecall to Untrusted Callee",
        desc="Calling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.",
        swc="112",
        advice="Use delegatecall with caution and make sure to never call into untrusted contracts. If the target address is derived from user input ensure to check it against a whitelist of trusted contracts.",
        level="error",
    ),
    11: VulInfo(
        name="DoS with Failed Call",
        desc="External calls can fail accidentally or deliberately, which can cause a DoS condition in the contract.",
        swc="113",
        advice="Implement the contract logic to handle failed calls.",
        level="error",
    ),
    12: VulInfo(
        name="Transaction Order Dependence",
        desc="A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.",
        swc="114",
        advice="From the user perspective it is possible to mediate the ERC20 race condition by setting approvals to zero before changing them.",
        level="error",
    ),
    13: VulInfo(
        name="Authorization through tx.origin",
        desc="tx.origin is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract.",
        swc="115",
        advice="If you want to use tx.origin for authorization, please use msg.sender instead.",
        level="warning",
    ),
    14: VulInfo(
        name="Timestamp Dependence",
        desc="Developers can't rely on the preciseness of the provided timestamp.",
        swc="116",
        advice="Use block number or external source of timestamp via oracles.",
        level="error",
    ),
    15: VulInfo(
        name="Signature Malleability",
        desc="A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.",
        swc="117",
        advice="A signature should never be included into a signed message hash to check if previously messages have been processed by the contract.",
        level="error",
    ),
    16: VulInfo(
        name="Weak Sources of Randomness from Chain Attributes",
        desc="Unable to create a strong enough source of randomness.",
        swc="120",
        advice="Using Bitcoin block hashes, as they are more expensive to mine.",
        level="error",
    ),
    17: VulInfo(
        name="Write to Arbitrary Storage Location",
        desc="The contract is responsible for ensuring that only authorized user or contract accounts may write to sensitive storage locations. If an attacker is able to write to arbitrary storage locations of a contract, the authorization checks may easily be circumvented. ",
        swc="124",
        advice="As a general advice, given that all data structures share the same storage (address) space, one should make sure that writes to one data structure cannot inadvertently overwrite entries of another data structure.",
        level="error",
    ),
    18: VulInfo(
        name="Arbitrary Jump with Function Type Variable",
        desc="The problem arises when a user has the ability to arbitrarily change the function type variable and thus execute random code instructions. ",
        swc="127",
        advice="The use of assembly should be minimal. A developer should not allow a user to assign arbitrary values to function type variables.",
        level="error",
    ),
    19: VulInfo(
        name="Call Stack Depth Limit Exceeding",
        desc="The Ethereum Virtual Machine implementation limits the call-stack's depth to 1024 frames. The call-stack's depth increases by one if a contract calls another via the send or call instruction. This opens an attack vector to deliberately cause the send instruction to fail.",
        swc="",
        advice="Specifically, an attacker can prepare a contract to call itself 1023 times before sending a transaction to KoET to claim the throne from the current king. Thus, the attacker ensures that the call-stack's depth of KoET reaches 1024, causing the send instruction in Line 15 to fail. As the result, the current king will not receive any payment.",
        level="error",
    ),
    20: VulInfo(
        name="Contract contains unknown address",
        desc="The contract contains an unknown address. This address might be used for some malicious activity.",
        swc="",
        advice="It is required to check the address. Also, it is required to check the code of the called contract for vulnerabilities.",
        level="warning",
    ),
    21: VulInfo(
        name="Checking for strict balance equality",
        desc="An adversary can forcibly send ether to any address via selfdestruct() or by mining.",
        swc="",
        advice="Use non-strict inequality.",
        level="warning",
    ),
    22: VulInfo(
        name="Use bytes instead of byte[]",
        desc="For lower gas consumption, byte[] is unsafe.",
        swc="",
        advice="Use bytes instead of byte[].",
        level="ignore",
    ),
    23: VulInfo(
        name="Use of call function with no data",
        desc="Use of low-level call function with no arguments provided.",
        swc="",
        advice="In this case, transfer or send function call is more secure. Another option is to implement the desired functionality in the separate public function of the target contract. Nevertheless, if use of call function is necessary due to the target contract design, gas limit should be added .gas().",
        level="warning",
    ),
    24: VulInfo(
        name="Use of in constructor",
        desc="Return statement is used in the contract's constructor. With return the process of deployment will differ from the intuitive one. For instance, deployed bytecode may not include functions implemented in the source.",
        swc="",
        advice="Do not use return in the contract's constructor in order to increase code readability and transparency unless you clearly understand this vulnerability. Generally, it is not safe to use smart contracts that have assembly in the constructor.",
        level="error",
    ),
    25: VulInfo(
        name="Deletion of dynamically-sized storage array",
        desc="Applying delete or .length = 0 to dynamically-sized storage arrays may lead to Out-of-Gas exception.",
        swc="",
        advice="Restrict adding too many elements into storage array. Otherwise, allow partial deletion of array's elements.",
        level="warning",
    ),
    26: VulInfo(
        name="Deprecated constructions",
        desc="Deprecated constructions: years, sha3, suicide, throw and constant functions. Use keccak256 instead of sha3.",
        swc="",
        advice="Use selfdestruct instead of suicide. Use revert() instead of throw. Use view instead of constant for functions. Use days instead of years.",
        level="ignore",
    ),
    27: VulInfo(
        name="Multiplication after division",
        desc="Solidity operates only with integers. Thus, if the division is done before the  multiplication, the rounding errors can increase dramatically.",
        swc="",
        advice="Carefully use * after / .",
        level="warning",
    ),
    28: VulInfo(
        name="Using continue in the do-while loop",
        desc="Prior to version 0.5.0, Solidity compiler handles continue inside do-while loop incorrectly: it ignores while condition.",
        swc="",
        advice="Do not use continue instruction in the do-while loop.",
        level="warning",
    ),
    29: VulInfo(
        name="Using approve function of the ERC-20 token standard",
        desc="The approve function of ERC-20 is vulnerable. Using front-running attack one can spend approved tokens before change of allowance value.",
        swc="",
        advice="Only use the approve function of the ERC-20 standard to change allowed amount to 0 or from 0 (wait till transaction is mined and approved).",
        level="warning",
    ),
    30: VulInfo(
        name="Return value is always false",
        desc="The transfer, transferFrom or approve functions do not return true for any values of input parameters.",
        swc="",
        advice="It is required to return true, if the function was successful.",
        level="warning",
    ),
    31: VulInfo(
        name="Use of unindexed arguments in ERC-20 standard events",
        desc="Address arguments of Transfer and Approve events of ERC-20 token standard must be indexed.",
        swc="",
        advice="Use indexed events' arguments, as stated in ERC-20 Token Standard.",
        level="warning",
    ),
    32: VulInfo(
        name="ERC-20 transfer should throw",
        desc="Functions of ERC-20 Token Standard should throw in special cases: a) transfer should throw if the _from account balance does not have enough tokens to spend; b) transferFrom should throw unless the _from account has deliberately authorized the sender of the message via some mechanism.",
        swc="",
        advice="The ERC20 standard recommends throwing exceptions in functions transfer and transferFrom.",
        level="error",
    ),
    33: VulInfo(
        name="Extra gas consumption",
        desc="State variable, .balance, or .length of non-memory array is used in the condition of for or while loop. In this case, every iteration of loop consumes extra gas.",
        swc="",
        advice="If state variable, .balance, or .length is used several times, holding its value in a local variable is more gas efficient. If .length of calldata-array is placed into local variable, the optimization will be less significant.",
        level="warning",
    ),
    34: VulInfo(
        name="Incorrect blockhash function",
        desc="Blockhash function returns a non-zero value only for 256 last blocks. Besides, it always returns 0 for the current block.",
        swc="",
        advice="",
        level="warning",
    ),
    35: VulInfo(
        name="Locked money",
        desc="Contracts programmed to receive ether should implement a way to withdraw it.",
        swc="",
        advice="Call transfer (recommended), send or call.value at least once.",
        level="warning",
    ),
    36: VulInfo(
        name="Overpowered role",
        desc="This function is callable only from one address. Therefore, the system depends heavily on this address. In this case, there are scenarios that may lead to undesirable consequences for investors, e.g. if the private key of this address becomes compromised.",
        swc="",
        advice="",
        level="warning",
    ),
    37: VulInfo(
        name="Private modifier",
        desc="Contrary to a popular misconception, the private modifier does not make a variable invisible. Miners have access to all contracts' code and data.",
        swc="",
        advice="",
        level="warning",
    ),
    38: VulInfo(
        name="Redundant fallback function",
        desc="The payment rejection fallback is redundant.",
        swc="",
        advice="Delete it.",
        level="warning",
    ),
    39: VulInfo(
        name="Output overwrites input of assembly CALLs",
        desc="Dangerous use of inline assembly instruction of CALL family, which overwrites the input with the output.",
        swc="",
        advice="",
        level="warning",
    ),
    40: VulInfo(
        name="Send instead of transfer",
        desc="The send function is called inside checks instead of using transfer.",
        swc="",
        advice="The recommended way to perform checked ether payments is addr.transfer(x), which automatically throws an exception if the transfer is unsuccessful.",
        level="warning",
    ),
    41: VulInfo(
        name="Incorrect Pure-functions",
        desc="In Solidity, functions that do not read from the state or modify it can be declared as pure.",
        swc="",
        advice="Use other function modifiers instead.",
        level="ignore",
    ),
    42: VulInfo(
        name="Incorrect View-functions",
        desc="In Solidity, functions that do not read from the state or modify it can be declared as view.",
        swc="",
        advice="Use other function modifiers instead.",
        level="ignore",
    ),
    43: VulInfo(
        name="ETH transfer inside the loop",
        desc="ETH is transferred in a loop. If at least one address cannot receive ETH (e.g. it is a contract with default fallback function), the whole transaction will be reverted.",
        swc="",
        advice="",
        level="warning",
    ),
    44: VulInfo(
        name="Non-strict comparison with zero",
        desc="Variables of uint type cannot be negative. Thus, comparing uint variable with zero (greater than or equal) is redundant. Also, it may lead to an underflow issue. Moreover, comparison with zero used in for-loop condition results in an infinite loop.",
        swc="",
        advice="Delete it.",
        level="warning",
    ),
    45: VulInfo(
        name="Use inline assembly",
        desc="Inline assembly is a way to access the Ethereum Virtual Machine at a low level. This discards several important safety features of Solidity.",
        swc="",
        advice="",
        level="ignore",
    ),
    46: VulInfo(
        name="Unsafe type inference",
        desc="May cause overflow error.",
        swc="",
        advice="Use correct integer type instead of var.",
        level="warning",
    ),
    47: VulInfo(
        name="Incorrect function signature",
        desc="In Solidity, the function signature is defined as the canonical expression of the basic prototype without data location specifier, i.e. the function name with the parenthesized list of parameter types. Parameter types are split by a single comma - no spaces are used. ",
        swc="",
        advice="Use uint256 and int256 instead of uint or int.",
        level="warning",
    ),
    48: VulInfo(
        name="Worse readability with revert",
        desc="Using the construction ''if (condition) {revert();}'' instead of ''require(condition);''",
        swc="",
        advice="Use require for better code readability.",
        level="warning",
    ),
    49: VulInfo(
        name="Using uintless number",
        desc="Vyper allows you to use unit label to either uint256, int128, or decimal type. This feature is implemented to increase code readability and security. Use of as_unitless_number() function can endanger contract security.",
        swc="",
        advice="Do not use as_unitless_number() function, use uint labels instead.",
        level="warning",
    ),
    50: VulInfo(
        name="ArbitraryTransfer problem",
        desc="When a hacker gets access to controlling this function, he can transfer tokens from one account to another one arbitrarily.",
        swc="",
        advice="",
        level="error",
    ),
    51: VulInfo(
        name="GenerateToken problem",
        desc="When a hacker gets access to controlling this function, he can generate any amount of tokens.",
        swc="",
        advice="",
        level="error",
    ),
    52: VulInfo(
        name="DestroyToken problem",
        desc="When a hacker gets access to controlling this function, he can destory any amount of tokens.",
        swc="",
        advice="",
        level="error",
    ),
    53: VulInfo(
        name="FrozeAccount problem",
        desc="When a hacker gets access to controlling this function, he can freeze any account.",
        swc="",
        advice="",
        level="error",
    ),
    54: VulInfo(
        name="DisableTransfer problem",
        desc="When a hacker gets access to controlling this function, he can disable all the transferations.",
        swc="",
        advice="",
        level="error",
    ),
}

VUL_MAPPING_TABLES = {
    "smart_check": {
        "SOLIDITY_VISIBILITY": 1,
        "SOLIDITY_UNUSED_FUNCTION_SHOULD_BE_EXTERNAL": 1,
        "SOLIDITY_TX_ORIGIN": 13,
        "SOLIDITY_PRAGMAS_VERSION": 3,
        "SOLIDITY_ARRAY_LENGTH_MANIPULATION": 17,
        "SOLIDITY_SAFEMATH": 2,
        "SOLIDITY_UNCHECKED_CALL": 4,
        "SOLIDITY_ADDRESS_HARDCODED": 20,
        "SOLIDITY_BALANCE_EQUALITY": 21,
        "SOLIDITY_BYTE_ARRAY_INSTEAD_BYTES": 22,
        "SOLIDITY_CALL_WITHOUT_DATA": 23,
        "SOLIDITY_CONSTRUCTOR_RETURN": 24,
        "SOLIDITY_DELETE_ON_DYNAMIC_ARRAYS": 25,
        "SOLIDITY_DEPRECATED_CONSTRUCTIONS": 26,
        "SOLIDITY_DIV_MUL": 27,
        "SOLIDITY_DO_WHILE_CONTINUE": 28,
        "SOLIDITY_ERC20_APPROVE": 29,
        "SOLIDITY_ERC20_FUNCTIONS_ALWAYS_RETURN_FALSE": 30,
        "SOLIDITY_ERC20_INDEXED": 31,
        "SOLIDITY_ERC20_TRANSFER_SHOULD_THROW": 32,
        "SOLIDITY_EXTRA_GAS_IN_LOOPS": 33,
        "SOLIDITY_INCORRECT_BLOCKHASH": 34,
        "SOLIDITY_LOCKED_MONEY": 35,
        "VYPER_LOCKED_MONEY": 35,
        "SOLIDITY_OVERPOWERED_ROLE": 36,
        "SOLIDITY_PRIVATE_MODIFIER_DOES_NOT_HIDE_DATA": 37,
        "SOLIDITY_REDUNDANT_FALLBACK_REJECT": 38,
        "SOLIDITY_REWRITE_ON_ASSEMBLY_CALL": 39,
        "SOLIDITY_SEND": 40,
        "SOLIDITY_SHOULD_NOT_BE_PURE": 41,
        "SOLIDITY_SHOULD_NOT_BE_VIEW": 42,
        "SOLIDITY_TRANSFER_IN_LOOP": 43,
        "SOLIDITY_UINT_CANT_BE_NEGATIVE": 44,
        "SOLIDITY_USING_INLINE_ASSEMBLY": 45,
        "SOLIDITY_VAR": 46,
        "SOLIDITY_VAR_IN_LOOP_FOR": 46,
        "SOLIDITY_WRONG_SIGNATURE": 47,
        "SOLIDITY_REVERT_REQUIRE": 48,
        "VYPER_UNITLESS_NUMBER": 49,
    },
    "myth": {
        "101": 2,
        "104": 4,
        "105": 5,
        "106": 6,
        "107": 7,
        "110": 8,
        "111": 9,
        "112": 10,
        "113": 11,
        "116": 14,
        "117": 15,
        "120": 16,
        "124": 17,
        "127": 18,
    },
    "oynete": {
        "integer_overflow": 2,
        "integer_underflow": 2,
        "money_concurrency": 12,
        "parity_multisig_bug_2": 6,
        "reentrancy": 7,
        "assertion_failure": 8,
        "time_dependency": 14,
        "callstack": 19

    },
    "bdd": {
        "ArbitraryTransfer": 50,
        "GenerateToken": 51,
        "DestroyToken": 52,
        "FrozeAccount": 53,
        "DisableTransfer": 54,
    },
}


def get_vul_info(vul_id):
    return __VULNERABILITIES[vul_id]
